state = {}

function map_list(lst, f)
   local out = {}
   for i=1,#lst do
      table.insert(out, f(lst[i]))
   end
   return out
end

-- Curried == operator
function eq(a)
   return function(b)
      return a == b
   end
end

function id(...)
   return ...
end

--- Concatenate two lists
function concat_list(a, b)
   assert(type(a) == "table", "LHS is not a table")
   assert(type(b) == "table", "RHS is not a table")
   local out = {}
   for i=1,#a do
      table.insert(out, a[i])
   end
   for i=1,#b do
      table.insert(out, b[i])
   end
   return out
end

function split_list(lst, on)
   local out = {}
   local acc = {}
   for i=1,#lst do
      local itm = lst[i]
      if on(itm) then
         table.insert(out, acc)
         acc = {}
      else
         table.insert(acc, itm)
      end
   end
   if #acc > 0 then
      table.insert(out, acc)
   end
   return out
end

function indent(s)
   return s:gsub("\n", "\n   ")
end

function list_to_string(lst)
   local out = "["
   for i=1,#lst do
      out = out .. indent("\n" .. tostring(lst[i]) .. ",")
   end
   out = out .. "\n]"
   return out
end

function table_to_string(tbl)
   if type(tbl) ~= "table" then
      return tostring(tbl)
   end

   local out = "{"
   for k,v in pairs(tbl) do
      out = out ..
         indent("\n" .. tostring(k) .. ": " .. table_to_string(v) .. ",")
   end
   out = out .. "\n}"
   return out
end

function enumerate(lst)
   local out = {}
   for i=1,#lst do
      table.insert(out, {i, lst[i]})
   end
   return out
end

function foldl(lst, init, f)
   local acc = init
   for i=1,#lst do
      acc = f(acc, lst[i])
   end
   return acc
end

function foldr(lst, init, f)
   local acc = init
   for i=#lst,1,-1 do
      acc = f(lst[i], acc)
   end
   return acc
end


function foldl_and(lst, f)
   return foldl(
      lst,
      {nil, true},
      function(acc, next)
         local prev,flag = unpack(acc)

         if not prev then
            return {next, flag}
         end

         return {next, flag and f(prev, next)}
      end
   )
end

function zip(la, lb)
   local out = {}
   for i=1,math.min(#la, #lb) do
      out[i] = {la[i], lb[i]}
   end
   return out
end

--- Return the first index for which the given function returns true, else nil
function index_of(lst, f)
   for i=1,#lst do
      if f(lst[i]) then
         return i
      end
   end
end

--- Return the amount of times f returns true for items in the given list
function count(lst, f)
   local acc = 0
   for i=1,#lst do
      if f(lst[i]) then
         acc = acc + 1
      end
   end
   return acc
end

--- Return a value -> count table of items in the given list
function counts(lst)
   local seen = {}
   for i=1,#lst do
      seen[lst[i]] = (seen[lst[i]] ~= nil and seen[lst[i]] + 1) or 1
   end
   return seen
end

--- Return true if lst contains no duplicate elements
function unique(lst)
   local seen = counts(lst)

   for _,v in pairs(seen) do
      if v > 1 then
         return false
      end
   end

   return true
end

--- Inhabited equivalent of nil
--- Useful for retaining a 'nothing' semantic while avoiding nil's
--- special interactions with table structure
local None, NoneMeta = {}, {}

function NoneMeta:__index() end
function NoneMeta:__newindex() end
function NoneMeta:__eq(b)
   return b == None
end

setmetatable(
    None,
    NoneMeta
)

function get(k)
   return function(t)
      return t[k]
   end
end

function set(k)
   return function(t, v)
      t[k] = v
      return t
   end
end

function get_typed(k, cond)
   return function(t)
      --printf("get_typed(%s, %s, %s)", k, cond, tostring(t))
      local v = t[k]

      if not cond(v) then
         --print("condition failed")
         return None
      end

      return v
   end
end

function set_typed(k, cond)
   return function(t, v)
      --print("set_typed", k, cond, t, v)

      if not cond(v) then
         --print("condition failed")
         return None
      end

      if t == None then
         return t
      end

      t[k] = v
      return t
   end
end

function compose(...)
   local args = {...}
   local out = function(t)
      return t
   end
   for i=1,#args do
      local old = out
      local f = args[i]
      out = function(t)
         return f(old(t))
      end
   end
   return out
end

--- Named constructor storage
Named = {}

--- Named metatable
NamedMeta = {}

function named(name, this, as)
   assert(type(name) == "string", "Name is not a string")
   assert(this ~= nil, "Named values must not be nil")
   assert(type(as) == "boolean", "As-flag must be a boolean")

   return setmetatable(
      {
         _name = name,
         _this = this,
         _as = as,
      },
      NamedMeta
   )
end

function NamedMeta:__index(key)
   return self._this[key]
end

function NamedMeta:__call(...)
   return self._this(...)
end

function NamedMeta:__tostring()
   if self._as then
      return self._name
   end

   local out = self._name
   if self._this ~= nil then
      out = out .. ": " .. tostring(self._this)
   end
   return out
end

is_named = function(t)
   return getmetatable(t) == NamedMeta
end

function NamedMeta.__concat(a, b)
   --print("Named.__concat:", a, b)

   local name = a._name

   -- Unwrap incoming named
   if is_named(b) then
      name = name .. "." .. b._name
      b = b._this
   end

   return named(
      name,
      a._this .. b,
      a._as
   )
end

function NamedMeta.__eq(a, b)
   --print("Named.__eq:", a, b)
   local x = a._this or a
   --print("x:", x)
   local y = b._this or b
   --print("y:", y)
   return x == y
end

--- Named constructor
function Named.with(name, this)
   return named(name, this, false)
end

function Named.as(name, this)
   return named(name, this, true)
end

--- Type predicates
is_any = Named.as(
   "any",
   function() return true end
)

is_nil = Named.as(
   "nil",
   function(t)
      return t == nil
   end
)

is_non_nil = Named.as(
   "non_nil",
   function(t)
      return t ~= nil
   end
)

is_boolean = Named.as(
   "boolean",
   function(t)
      return type(t) == "boolean"
   end
)

is_number = Named.as(
   "number",
   function(t)
      return type(t) == "number"
   end
)

is_string = Named.as(
   "string",
   function(t)
      return type(t) == "string"
   end
)

is_table = Named.as(
   "table",
   function(t)
      return type(t) == "table" and getmetatable(t) == nil
   end
)

is_indexable = Named.as(
   "indexable",
   function(t)
      if is_table(t) then
         return true
      end

      local mt = getmetatable(t)
      if mt and mt.__index ~= nil then
         return true
      end

      return false
   end
)

is_callable = Named.as(
   "callable",
   function(f)
      if type(f) == "function" then
         return true
      end

      local mt = getmetatable(f)
      if not mt then
         return false
      end

      return mt.__call ~= nil
   end
)

is_vector = Named.as(
   "vector",
   function(t)
      return type(t) == "userdata"
         and is_number(t.x)
         and is_number(t.y)
         and is_number(t.z)
   end
)

is_matrix= Named.as(
   "matrix",
   function(t)
      return type(t) == "userdata"
         and is_vector(t.i)
         and is_vector(t.j)
         and is_vector(t.k)
         and is_vector(t.c)
   end
)

--- Span index
Span = {}

--- Span metatable
SpanMeta = {
   __index = Span
}

--- Span constructor
function Span.new(...)
   local args = {...}
   assert(unique(args), "Span members must be unique")
   return setmetatable(
      { _lst = args },
      SpanMeta
   )
end

is_span = Named.as(
   "span",
   function(t)
      return getmetatable(t) == SpanMeta
   end
)

function Span:at_start(f)
   assert(count(f, self._lst) == 0, "Span members must be unique")
   table.insert(self._lst, 1, f)
   return self
end

function Span:at_end(f)
   assert(count(f, self._lst) == 0, "Span members must be unique")
   table.insert(self._lst, f)
   return self
end

function SpanMeta:__tostring()
   local out = "Span["
   for i=1,#self._lst do
      out = out .. indent("\n" .. tostring(self._lst[i]) .. ",")
   end
   out = out .. "\n]"
   return out
end

function SpanMeta.__concat(src, dst)
   -- print("Span.__concat:\nLHS: ", src, "\nRHS: ", dst)

   assert(is_span(dst), "Destination is not a Span")

   if #src._lst == 0 then
      return dst
   elseif #dst._lst == 0 then
      return src
   end

   local indices = map_list(
      src._lst,
      function(a)
         return index_of(
            dst._lst,
            function(b)
               return a == b
            end
         ) or -1
      end
   )

   --print("indices:", unpack(indices))

   local _, solvable = unpack(foldl(
      indices,
      {nil, true},
      function(acc, next)
         local idx, state = unpack(acc)
         --print("idx:", idx)
         --print("state:", state)
         --print("next:", next)
         --print()

         if not state then
            return {idx, state}
         end

         if not idx then
            return {next, state}
         end

         if next == -1 then
            return acc
         end

         --print("idx < next:", idx < next)

         return {next, idx < next}
      end
   ))

   --print("solvable: %s", solvable)

   if not solvable then
      assert(
         nil,
         string.format(
            "Unsolvable Span orderings:\nSrc: %s\nDst: %s",
            src,
            dst
         )
      )
   end

   local edges = count(
      indices,
      function(i)
         return i ~= -1
      end
   )

   if edges == 0 then
      assert(
         nil,
         string.format(
            "No common edges:\nSrc: %s\nDst: %s",
            src, dst
         )
      )
   end

   local src_indices = zip(src._lst, indices)
   --print("src_indices:", unpack(src_indices))

   local head = {}
   for i=1,#dst._lst do
      table.insert(head, dst._lst[i])
   end

   local tail = {}

   head,tail = unpack(foldr(
      src_indices,
      {head, tail},
      function(next, acc)
         local h,t = unpack(acc)
         --print("head:", unpack(h))
         --print("tail:", unpack(t))

         local src,idx = unpack(next)
         --print("src:", src)
         --print("idx:", idx)

         if idx ~= -1 then
            while #h > idx do
               table.insert(t, 1, table.remove(h))
            end
         end

         if src == h[#h] then
            table.remove(h)
         end

         table.insert(t, 1, src)

         --print()
         return acc
      end
   ))

   return Span.new(unpack(concat_list(head, tail)))
end

function SpanMeta.__eq(as, bs)
   --print("Span.__eq:", as, bs)

   local out = true

   if #as._lst ~= #bs._lst then
      out = false
   end

   for i=1,#as._lst do
      if as._lst[i] ~= bs._lst[i] then
         out = false
      end
   end

   --print("Return:", out)

   return out
end

--- Tests
--[[
start = Named.with(
   "start",
   1
)

foo = Named.with(
   "foo",
   2
)

bar = Named.with(
   "bar",
   3
)

baz = Named.with(
   "baz",
   4
)

gub = Named.with(
   "gub",
   5
)

zab = Named.with(
   "zab",
   6
)

rab = Named.with(
   "rab",
   7
)

oof = Named.with(
   "oof",
   8
)

finish = Named.with(
   "finish",
   9
)

local foo_bar_baz = Named.with("foo->bar->baz", Span.new(start, foo, bar, baz, finish))
local zab_rab_oof = Named.with("foo->bar->baz", Span.new(start, zab, rab, oof, finish))
local bar_gub_rab = Named.with("bar->gub->rab", Span.new(start, bar, gub, rab, finish))

local mergedA = Named.with(
   "mergedA",
    bar_gub_rab .. zab_rab_oof .. foo_bar_baz
)
print(mergedA)

local mergedB = Named.with(
   "mergedB",
    zab_rab_oof .. foo_bar_baz .. bar_gub_rab
)
print(mergedB)

local mergedC = Named.with(
   "mergedC",
    foo_bar_baz .. bar_gub_rab .. zab_rab_oof
)
print(mergedC)
--]]

--- System index
System = {}

--- System metatable
SystemMeta = {
   __index = System
}

is_system = Named.as(
   "system",
   function(t)
      return getmetatable(t) == SystemMeta
   end
)

function System.new(name)
   return setmetatable(
      {
         _name = name,
         _inputs = {},
         _outputs = {},
         _f = id
      },
      SystemMeta
   )
end

function System:reads(...)
   local inputs = {...}
   for i=1,#inputs do
      local input = inputs[i]
      if not input then
         assert(
            nil,
            string.format(
               "Invalid input at index %s:\n%s",
               i, table_to_string(inputs)
            )
         )
      end
      if not input._get or not input._set then
         assert(
            nil,
            string.format(
               "Input is not a Lens: %s",
               input
            )
         )
      end
   end
   self._inputs = inputs
   return self
end

function System:writes(...)
   local outputs = {...}
   for i=1,#outputs do
      local output = outputs[i]
      if not output._get or not output._set then
         assert(
            nil,
            string.format(
               "Output is not a Lens: %s",
               output
            )
         )
      end
   end
   self._outputs = outputs
   return self
end

function System:via(f)
   if not is_callable(f) then
      assert(
         nil,
         string.format("System body is not a callable value: %s", f)
      )
   end
   self._f = f
   return self
end

function SystemMeta:__call(ctx)
   --print("call", self)
   local inputs = {}
   for i=1,#self._inputs do
      local lens = self._inputs[i]
      local v = lens:get(ctx)
      if v == None then
         return ctx
      end
      table.insert(inputs, v)
   end

   local outputs = {self._f(unpack(inputs))}
   for i=1,#self._outputs do
      local output = outputs[i]
      local lens = self._outputs[i]
      lens:set(ctx, output)
   end

   return ctx
end

function SystemMeta.__tostring(self)
   return string.format(
      "%s(%s) => (%s)",
      self._name,
      table.concat(map_list(self._inputs, tostring), ", "),
      table.concat(map_list(self._outputs, tostring), ", ")
   )
end

function SystemMeta.__concat(a, b)
   if is_system(b) then
      return Serial.new(a, b)
   elseif is_serial(b) then
      b:push_front(a)
      return b
   else
      assert(
         nil,
         string.format(
            "Invalid concatenation:\nLHS: %s\nRHS: %s",
            a, b
         )
      )
   end
end

--- Optic index higher-order-function container
Optic = {}

--- Optic metatable higher-order-function container
OpticMeta = {}

function Optic.new(mt)
   return function(get, set)
      if not is_callable(get) then
         assert(
            nil,
            string.format("Getter is not a callable value: %s", get)
         )
      end
      if not is_callable(set) then
         assert(
            nil,
            string.format("Setter is not a callable value: %s", set)
         )
      end
      return setmetatable(
         {
            _name = nil,
            _get = get,
            _set = set
         },
         mt
      )
   end
end

function Optic.at(ind, suf)
   return function(k)
      return ind.new(get(k), set(k)):name(k .. (suf or ""))
   end
end

function Optic.name(this, name)
   this._name = name
   return this
end

function Optic.where(ind, suf)
   return function(k, pg, ps)
      return ind.new(
         get_typed(k, pg),
         set_typed(k, ps or pg)
      ):name(k .. (suf or "") .. ": " .. tostring(pg) .. (ps and (" -> " .. tostring(ps)) or ""))
   end
end

function OpticMeta.__tostring(tn)
   return function(self)
      local exp = self._name

      local def = tn .. "<"
         .. tostring(self._get)
         .. ", "
         .. tostring(self._set)
         .. ">"

      return exp or def
   end
end

function OpticMeta.__concat(a, b)
   local an = a._name or tostring(a)
   local bn = b._name or tostring(b)
   if b.cond then
      bn = bn .. ": " .. tostring(b.cond)
   end
   return Lens.new(
      compose(a._get, b._get),
      function(t, v)
         return a:map(
            t,
            function(x)
               return b:set(x, v)
            end
         )
      end
   )
   :name(an .. " . " .. bn)
end

--- Lens index
Lens = {}

--- Lens metatable
LensMeta = {__index = Lens}

Lens.name = Optic.name
Lens.new = Optic.new(LensMeta)
Lens.at = Optic.at(Lens)
Lens.where = Optic.where(Lens)

LensMeta.__tostring = OpticMeta.__tostring("Lens")
LensMeta.__concat = OpticMeta.__concat

function Lens:get(t)
   return self._get(t)
end

function Lens:set(t, v)
   return self._set(t, v)
end

function Lens:map(t, f)
   return self:set(t, f(self:get(t)))
end

--- Prism index
Prism = {}

--- Prism metatable
PrismMeta = { __index = Prism }

Prism.new = Optic.new(PrismMeta)
Prism.name = Optic.name
Prism.at = Optic.at(Prism, "?")
Prism.where = Optic.where(Prism, "?")
PrismMeta.__tostring = OpticMeta.__tostring("Prism")
PrismMeta.__concat = OpticMeta.__concat

function Prism:get(t)
   local v = self._get(t)
   if v == None then
      return None
   end
   return v
end

function Prism:set(t, v)
   if self:get(t) == None then
      return t
   end
   return self._set(t, v)
end

function Prism:map(t, f)
   local v = self:get(t)

   if v == None then
      return t
   end

   v = f(v)

   if v == None then
      return t
   end

   return self:set(t, v)
end

--- Ordered set index
local OrdSet = {}

--- Ordered set metatable
local OrdSetMeta = { __index = OrdSet }

function OrdSet.new(...)
   local lst = {...}
   if not unique(lst) then
      assert(
         nil,
         string.format(
            "An ordered set may not contain duplicate members:\n%s",
            list_to_string(lst)
         )
      )
   end
   return setmetatable(
      { _lst = lst },
      OrdSetMeta
   )
end

is_ord_set = Named.as(
   "ord_set",
   function(t)
      return getmetatable(t) == OrdSetMeta
   end
)

function OrdSet:push_front(t)
   if count(self._lst, function(u) return u == t end) > 0 then
      assert(nil, "OrdSet may not contain duplicates.")
   end

   table.insert(self._lst, 1, t)
end

function OrdSet:push_back(t)
   if count(self._lst, function(u) return u == t end) > 0 then
      assert(nil, "OrdSet may not contain duplicates.")
   end

   table.insert(self._lst, t)
end

function OrdSetMeta:__tostring()
   local out = "OrdSet["
   for i=1,#self._lst do
      out = out .. indent("\n" .. tostring(self._lst[i]) .. ",")
   end
   out = out .. "\n]"
   return out
end

function OrdSetMeta.__concat(a, b)
   if not is_ord_set(b) then
      assert(
         nil,
         string.format("Invalid concatenation:\nLHS: %s\nRHS: %s", a, b)
      )
   end

   return OrdSet.new(unpack(concat_list(a._lst, b._lst)))
end

--print(OrdSet.new(1, 2) .. OrdSet.new(3, 4) .. OrdSet.new(5, 6))

--- Execution index
Executor = {}

--- Execution metatable
ExecutorMeta = {
    __index = Executor,
}

function Executor.new(mt)
   return function(...)
      local lst = {...}
      for i=1,#lst do
         local f = lst[i]
         if not is_callable(f) then
            assert(
               nil,
               string.format(
                  "Executor member is not a callable value: %s",
                  f
               )
            )
         end
      end

      return setmetatable(
         { _set = OrdSet.new(unpack(lst)) },
         mt
      )
   end
end


function ExecutorMeta.__tostring(name)
   return function(this)
      local out = name .. "["
      for i=1,#this._set._lst do
         out = out .. indent("\n" .. tostring(this._set._lst[i]) .. ",")
      end
      out = out .. "\n]"
      return out
   end
end

function ExecutorMeta.__concat(mt, ind, name)
   return function(a, b)
      if not getmetatable(b) == mt then
         assert(
            nil,
            string.format("Not a %s: %s", name, b)
         )
      end
      return ind.new(unpack((a._set .. b._set)._lst))
   end
end


--- Serial index
Serial = {}

--- Serial metatable
SerialMeta = {
   __index = function(this, key)
      return this._set[key] or Serial[key]
   end
}

Serial.new = Executor.new(SerialMeta)

local serial_concat = ExecutorMeta.__concat(SerialMeta, Serial, "Serial")
SerialMeta.__concat = function(a, b)
   if is_schedule(b) then
      return b:concat(a)
   elseif is_serial(b) then
      for i=1,#a._lst do
         for j=1,#b._lst do
            if a._lst[i] == a._lst[j] then
               return a .. b .. Schedule.new()
            end
         end
      end

      return serial_concat(a, b)
   elseif is_system(b) then
      a:push_back(b)
      return a
   end

   assert(
      nil,
      string.format(
         "Invalid concatenation:\nLHS: %s\nRHS: %s",
         a, b
      )
   )
end

SerialMeta.__tostring = ExecutorMeta.__tostring("Serial")

function is_serial(t)
   return getmetatable(t) == SerialMeta
end

function SerialMeta:__call(...)
   local acc = {...}
   for i=1,#self._set._lst do
      local f = self._set._lst[i]
      acc = {f(unpack(acc))}
   end
   return unpack(acc)
end

--- Parallel index
Parallel = {}

--- Parallel metatable
ParallelMeta = { __index = Parallel }

Parallel.new = Executor.new(ParallelMeta)

ParallelMeta.__tostring = ExecutorMeta.__tostring("Parallel")

function is_parallel(t)
   return getmetatable(t) == ParallelMeta
end

function ParallelMeta:__call(...)
   local acc = {...}
   for i=1,#self._set._lst do
      local f = self._set._lst[i]
      acc = {f(unpack(acc))}
   end
   return unpack(acc)
end

--[[
print(Parallel.new(
   function(s)
      print("foo")
      return s
   end,
   function(s)
      print("bar")
      return s
   end
))

local parA = Parallel.new(
   Named.with(
      "foo",
      function(s)
         print("foo")
         return s
      end
   ),
   Named.with(
      "bar",
      function(s)
         print("bar")
         return s
      end
   )
)

local parB = Parallel.new(
   Named.with(
      "baz",
      function(s)
         print("baz")
         return s
      end
   ),
   Named.with(
      "gub",
      function(s)
         print("gub")
         return s
      end
   )
)

local ser = Serial.new(parA, parB)

print(ser)
print(unpack(ser({1,2,3})))
--]]

--- Schedule index
Schedule = {}

--- Schedule metatable
ScheduleMeta = { __index = Schedule }

function Schedule.new()
   return setmetatable(
      { _ser = Serial.new() },
      ScheduleMeta
   )
end

function is_schedule(t)
   return getmetatable(t) == ScheduleMeta
end

function Schedule:concat(a)
   --[[
   printf(
      "Schedule.concat:\nLHS: %s\nRHS: %s",
      self, a
   )
   --]]

   if is_system(a) then
      a = Serial.new(a)
   elseif not is_serial(a) then
      assert(
         nil,
         string.format("Value is not a Serial: %s", a)
      )
   end

   -- If this is an empty schedule, emplace the values directly
   if #self._ser._set._lst == 0 then
      for i=1,#a._set._lst do
         local itm = a._set._lst[i]
         local par = Parallel.new(itm)
         table.insert(self._ser._set._lst, par)
      end

      --printf("Out: %s", self)

      return self
   end

   -- Find indices of pre-existing entries to use as anchor points
   local inds = {}
   for i=1,#a._set._lst do
      local itm = a._set._lst[i]
      inds[i] = -1
      for j=1,#self._ser._set._lst do
         local par = self._ser._set._lst[j]
         local ind = index_of(
            par._set._lst,
            function(cand)
               return cand == itm
            end
         )
         if ind then
            inds[i] = j
         end
      end
   end

   --printf("inds: %s", list_to_string(inds))

   -- Error out if there are no points of reference
   local anchored = count(
      inds,
      eq(-1)
   ) < #inds
   if not anchored then
      assert(
         nil,
         string.format(
            "No common members in concatenation:\nSrc: %s\nDst: %s",
            a,
            self
         )
      )
   end

   -- Error out if the source and destination disagree on ordering
   local sorted = foldl_and(
      inds,
      function(a, b)
         if a == -1 or b == -1 then
            return true
         end
      return a < b
   end)

   if not sorted then
      assert(
         nil,
         string.format(
            "Concatenation operands disagree on ordering:\nSrc: %s\nDst: %s",
            a,
            self
         )
      )
   end

   -- If duplicate indices exist, split them into separate parallels
   --printf("splitting")
   local prev = nil
   local acc = 0
   for i=1,#inds do
      local ind = inds[i]
      --[[
      printf("prev: %s", prev)
      printf("ind: %s", ind)
      printf("entry: %s", a._set._lst[i])
      --]]

      if ind == -1 then
         goto next_ind
      end

      if not prev then
         prev = ind
      elseif ind == prev then
         --printf("list: %s", unpack(self._ser._set._lst[ind]._set._lst))
         local target = index_of(
            self._ser._set._lst[ind]._set._lst,
            function(cand)
               return cand == a._set._lst[i]
            end
         )
         --printf("target: %s", target)
         local res = table.remove(
            self._ser._set._lst[ind]._set._lst,
            target
         )
         table.insert(self._ser._set._lst, ind + 1, Parallel.new(res))
         acc = acc + 1
      end

      inds[i] = inds[i] + acc

      ::next_ind::
   end

   --[[
   printf("inds split: %s", table_to_string(inds))
   printf("split: %s", self)
   --]]

   --printf("allocating")
   local last = nil
   local gap = 0
   local ofs = 0
   for i=1,#inds do
      local ind = inds[i]
      if ind == -1 then
         gap = gap + 1
      else
         if last then
            local delta = ind - last
            --printf("gap: %s, delta: %s", gap, delta)
            while gap > delta - 1 do
               table.insert(self._ser._set._lst, ind, Parallel.new())
               gap = gap - 1
               ofs = ofs + 1
            end
            last = ind
            inds[i] = inds[i] + ofs
         else
            last = ind
         end
      end


      ::next_ind::
   end

   --[[
   printf("inds allocated: %s", table_to_string(inds))
   printf("allocated: %s", self)
   --]]

   -- Insert
   --printf("inserting")
   local foo = 1
   local base = nil
   local rem = foldl(
      inds,
      {},
      function(acc, next)
         --[[
         printf("acc: %s", acc)
         printf("next: %s", next)
         --]]
         if next == -1 then
            --printf("unindexed, accumulating")
            table.insert(acc, a._set._lst[foo])
         else
            base = next
            for i=1,#acc do
               local target = base - i
               local itm = table.remove(acc)
               --[[
               printf(
                  "inserting to parallel %s | %s | %s",
                  target,
                  list_to_string(self._ser._set._lst[target]._set._lst),
                  itm
               )
               --]]
               table.insert(
                  self._ser._set._lst[target]._set._lst,
                  itm
               )
            end
         end
         foo = foo + 1
         return acc
      end
   )

   --print("rem:", unpack(rem))

   for i=1,#rem do
      if not self._ser._set._lst[base + i] then
         --print("allocating new parallel at", base + 1)
         table.insert(self._ser._set._lst, Parallel.new())
      end
      --print("inserting to parallel", base + i)
      table.insert(
         self._ser._set._lst[base + i]._set._lst,
         table.remove(rem, 1)
      )
   end


   --printf("Out: %s", self)

   return self
end

function ScheduleMeta.__concat(a, b)
   return a:concat(b)
end

function ScheduleMeta:__tostring()
   local out = "Schedule["
   out = out .. indent("\n" .. tostring(self._ser))
   out = out .. "\n]"
   return out
end

function ScheduleMeta:__call(...)
   return self._ser(...)
end

--- Tests
--[[

local la = Lens.where("a", is_number)
local lb = Lens.where("b", is_number)
local lc = Lens.where("c", is_boolean)
local ld = Lens.where("d", is_indexable)
local not_ld = Prism.where("d", is_nil, is_table)
local le = Lens.where("e", is_number)

do_a = System.new("do_a")
   :writes(la)
   :via(function()
         print("do_a")
      return 2
   end)

do_b = System.new("do_b")
   :reads(la)
   :writes(lb)
   :via(function(b)
      print("do_b")
      return b * 2
   end)

do_c = System.new("do_c")
   :reads(la)
   :writes(lc)
   :via(function(a)
      print("do_c")
      return a > 1
   end)

do_d = System.new("do_d")
   :reads(lb, lc)
   :writes(
      ld .. le
   )
   :via(function(b, c)
      print("do_d")
      return b + (c and 4 or 5)
   end)

do_e = System.new("do_e")
   :writes(not_ld)
   :via(function()
      print("do_e")
      return {}
   end)

print(do_a)
print(do_b)
print(do_c)
print(do_d)
print(do_e)

-- A branches to B and C
local abd = do_a .. do_b .. do_d
print("abd", abd)

local acd = do_a .. do_c .. do_d
print("acd", acd)

-- BUG: Order-dependent, breaks with right association
local de = do_d .. do_e
print("de", de)

sched = Schedule.new()
sched:concat(abd)
sched:concat(acd)
sched:concat(de)

print(sched)

local ctx = {}

print("ctx: " .. table_to_string(ctx))

ctx = sched(ctx)
print("first run: " .. table_to_string(ctx))

ctx = sched(ctx)
print("second run: " .. table_to_string(ctx))
--]]

on_level_call = Schedule.new()
on_level_call_start = System.new("level_call_start")
on_level_call_finish = System.new("level_call_finish")
on_level_call:concat(on_level_call_start .. on_level_call_finish)

actor_on_update = Schedule.new()
actor_on_update_start = System.new("actor_on_update_start")
actor_on_update_finish = System.new("actor_on_update_finish")
actor_on_update:concat(actor_on_update_start .. actor_on_update_finish)

actor_on_first_update = Schedule.new()
actor_on_first_update_start = System.new("actor_on_first_update_start")
actor_on_first_update_finish = System.new("actor_on_first_update_finish")
actor_on_first_update:concat(
    actor_on_first_update_start .. actor_on_first_update_finish
)

actor_on_weapon_fired = Schedule.new()
actor_on_weapon_fired_start = System.new("actor_on_weapon_fired_start")
actor_on_weapon_fired_finish = System.new("actor_on_weapon_fired_finish")
actor_on_weapon_fired:concat(
   actor_on_weapon_fired_start .. actor_on_weapon_fired_finish
)

on_key_press = Schedule.new()
on_key_press_start = System.new("on_key_press_start")
on_key_press_finish = System.new("on_key_press_finish")
on_key_press:concat(
   on_key_press_start .. on_key_press_finish
)

on_before_mouse_move = Schedule.new()
on_before_mouse_move_start = System.new("on_before_mouse_move_start")
on_before_mouse_move_finish = System.new("on_before_mouse_move_finish")
on_before_mouse_move:concat(
   on_before_mouse_move_start .. on_before_mouse_move_finish
)

ERROR_DURATION = 120 -- 2 minutes

function handle_error(e, stack)
   local msg = "ERROR: " .. e

   local stack_lines = str_explode(trim(stack), "\n")
   if db.actor then
      for i=#stack_lines,1,-1 do
         news_manager.send_tip(
            db.actor,
            stack_lines[i],
            nil,
            nil,
            ERROR_DURATION * 1000
         )
      end

      news_manager.send_tip(
         db.actor,
         msg,
         nil,
         nil,
         ERROR_DURATION * 1000
      )
   end

   actor_menu.set_fade_msg(
      msg,
      ERROR_DURATION,
      {R = 255, G = 0, B = 0}
   )

   printe(msg .. stack)
end

do_on_level_call = function()
   local res, out = pcall(on_level_call, state)
   if not res then
      RemoveUniqueCall(do_on_level_call)
      handle_error(out, callstack(false, true))
   end
end

do_actor_on_update = function()
   local res, out = pcall(actor_on_update, state)
   if not res then
      UnregisterScriptCallback("actor_on_update", do_actor_on_update)
      handle_error(out, callstack(false, true))
   end
end

do_actor_on_first_update = function()
   local res, out = pcall(actor_on_first_update, state)
   if not res then
      UnregisterScriptCallback(
         "actor_on_first_update",
         do_actor_on_first_update
      )
      handle_error(out, callstack(false, true))
   end
end

do_actor_on_weapon_fired = function()
   local res, out = pcall(actor_on_weapon_fired, state)
   if not res then
      UnregisterScriptCallback(
         "actor_on_weapon_fired",
         do_actor_on_weapon_fired
      )
      handle_error(out, callstack(false, true))
   end
end

do_on_before_mouse_move = function(x, y, disabled, flags)
   state.mouse = {
      x = x,
      y = y,
      disabled = disabled,
      override = false,
   }
   local res, out = pcall(on_before_mouse_move, state)
   if not res then
      UnregisterScriptCallback(
         "on_before_mouse_move",
         do_on_before_mouse_move
      )
      handle_error(out, callstack(false, true))
   end
   flags.ret_value = state.mouse.override
   state.mouse = nil
end

do_on_key_press = function(key)
   state.keyboard = {
      key = key
   }
   local res, out = pcall(on_key_press, state)
   if not res then
      UnregisterScriptCallback(
         "on_key_press",
         do_on_key_press
      )
      handle_error(out, callstack(false, true))
   end
   state.keyboard = nil
end

function on_game_start()
   printf("schedule_new on_game_start")

   printf("on_level_call: %s", on_level_call)
   printf("actor_on_update: %s", actor_on_update)
   printf("actor_on_first_update: %s", actor_on_first_update)
   printf("actor_on_weapon_fired: %s", actor_on_weapon_fired)
   printf("on_key_press: %s", on_key_press)

   AddUniqueCall(do_on_level_call)
   RegisterScriptCallback("actor_on_update", do_actor_on_update)
   RegisterScriptCallback("actor_on_first_update", do_actor_on_first_update)
   RegisterScriptCallback("actor_on_weapon_fired", do_actor_on_weapon_fired)
   RegisterScriptCallback("on_before_mouse_move", do_on_before_mouse_move)
   RegisterScriptCallback("on_key_press", do_on_key_press)
end
