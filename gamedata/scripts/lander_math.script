----------------------------------------------------------------------------
-- Math Utilities
----------------------------------------------------------------------------
-- Implemented by Lhan
----------------------------------------------------------------------------

-- Imports

-- Constants

PI = 3.14159
TAU = PI * 2
RAD2DEG = 180 / PI
DEG2RAD = PI / 180

POS_X = vector():set(1, 0, 0)
POS_Y = vector():set(0, 1, 0)
POS_Z = vector():set(0, 0, 1)

NEG_X = vector():set(-1, 0, 0)
NEG_Y = vector():set(0, -1, 0)
NEG_Z = vector():set(0, 0, -1)

EPSILON = 0.00000001

-- Implementation

---@param n number
---@return number
function sign(n)
   if n > 0 then
      return 1
   elseif n < 0 then
      return -1
   else
      return 0
   end
end

---@param f number
---@return number
function deg(f)
   return f * RAD2DEG
end

---@param f number
---@return number
function rad(f)
   return f * DEG2RAD
end

function vector_valid(vec)
   return vec ~= nil
      and vec.x == vec.x
      and vec.y == vec.y
      and vec.z == vec.z
end

---@param v vector
---@param k vector
---@param theta number
---@return vector
function vector_rotate(v, k, theta)
   assert(vector_valid(v), "Invalid vector")
   assert(vector_valid(k), "Invalid axis")
   assert(theta ~= nil, "Invalid angle")

   if math.abs(theta) < EPSILON
   or theta ~= theta
   then
      return v
   end

   local cos_theta = math.cos(theta)
   local sin_theta = math.sin(theta)

   return vector()
      :set(v)
      :mul(cos_theta)
      :add(vector_cross(k, v):mul(sin_theta))
      :add(vector():set(k):mul(k:dotproduct(v)):mul(1 - cos_theta))
      
end

---@param v vector
---@param theta number
---@return vector
function vector_rotate_x(v, theta)
   return vector_rotate(v, vector():set(1, 0, 0), theta)
end

---@param v vector
---@param theta number
---@return vector
function vector_rotate_y(v, theta)
   return vector_rotate(v, vector():set(0, 1, 0), theta)
end

---@param v vector
---@param theta number
---@return vector
function vector_rotate_z(v, theta)
   return vector_rotate(v, vector():set(0, 0, 1), theta)
end

---@param v vector
---@return vector
function vector_xz(v)
   return vector():set(v.x, 0, v.z)
end

--- Basis metatable
---@class basis
---@field x vector
---@field y vector
---@field z vector
local Basis = {}

--- Basis Constructor
---@param x? vector
---@param y? vector
---@param z? vector
---@return basis
function basis(x, y, z)
   return setmetatable(
      {
         x = x or vector():set(POS_X),
         y = y or vector():set(POS_Y),
         z = z or vector():set(POS_Z),
      },
      {
         __index = Basis
      }
   )
end

---@return basis
function Basis:normalize()
   return basis(
      self.x:normalize(),
      self.y:normalize(),
      self.z:normalize()
   )
end

---@param k vector
---@param theta number
---@return basis
function Basis:rotate(k, theta)
   if theta == 0/0 then
      return self
   end

   if theta == 1/0 then
      return self
   end

   if math.abs(theta) < EPSILON then
      return self
   end

   return basis(
      vector_rotate(self.x, k, theta),
      vector_rotate(self.y, k, theta),
      vector_rotate(self.z, k, theta)
   ):normalize()
end

---@param theta number
---@return basis
function Basis:rotate_x(theta)
   return self:rotate(POS_X, theta)
end

---@param theta number
---@return basis
function Basis:rotate_y(theta)
   return self:rotate(POS_Y, theta)
end

---@param theta number
---@return basis
function Basis:rotate_z(theta)
   return self:rotate(POS_Z, theta)
end

---@param hpb vector
---@return basis
function Basis:rotate_hpb(hpb)
   local out = basis(
      vector():set(self.x),
      vector():set(self.y),
      vector():set(self.z)
   )
   out = out:rotate(out.y, -hpb.x)
   out = out:rotate(out.x, -hpb.y)
   out = out:rotate(out.z, -hpb.z)
   return out
end

--- Transform the given vector into basis-space
---@param basis basis
---@param vec vector
---@return vector
function world_to_basis(basis, vec)
   return vector():set(
      vec:dotproduct(basis.x),
      vec:dotproduct(basis.y),
      vec:dotproduct(basis.z)
   )
end

--- Convert a Heading-Pitch-Bank rotation
--- (such as those returned from bone_direction)
--- into a direction vector
---@param hpb vector
---@return vector
function hpb_to_direction(hpb)
   return basis():rotate_hpb(hpb).z
end

--- Return the rotation between the given vectors in axis-angle form
---@param va vector
---@param vb vector
---@return vector?, number?
function vector_axis_angle(va, vb)
   local axis = vector_cross(va, vb)
   local mag = axis:magnitude()

   if mag ~= mag
      or mag < EPSILON
   then
      printf("Invalid magnitude")
      return nil
   end

   local angle = math.asin(mag)

   if angle ~= angle
      or math.abs(angle) < EPSILON
   then
      printf("Invalid angle")
      return nil
   end

   axis:normalize()

   return axis, angle
end

--- Convert from an axis-angle representation to euler angles
---@param axis vector
---@param angle number
---@return vector
function axis_angle_to_euler(axis, angle)
   local s = math.sin(angle)
   local c = math.cos(angle)
   local t = 1 - c;

   if (axis.x * axis.y * t + axis.z * s) > 1.0 - EPSILON then
      return vector():set(
         2 * math.atan2(axis.x * math.sin(angle/2), math.cos(angle/2)),
         PI / 2,
         0
      )
   end

   if (axis.x * axis.y * t + axis.z * s) < -(1.0 - EPSILON) then
      return vector:set(
         -2 * math.atan2(axis.x * math.sin(angle / 2), math.cos(angle/2)),
         -PI / 2,
         0
      )
   end

   return vector():set(
      math.atan2(axis.y * s - axis.x * axis.z * t, 1 - (axis.y * axis.y + axis.z * axis.z) * t),
      math.atan2(axis.x * s - axis.y * axis.z * t, 1 - (axis.x * axis.x + axis.z * axis.z) * t),
      math.asin(axis.x * axis.y * t + axis.z * s)
   )
end

--- Interpolate between two vectors
---@param a vector
---@param b vector
---@param t number
function vector_lerp(a, b, t)
   local delta = vector():set(b):sub(a)
   return vector():set(a:add(delta:mul(t)))
end

--- 3-vector metatable
---@class vec3
---@field x number
---@field y number
---@field z number
---@field vec vector
local Vec3 = {}

function is_number(num)
   return type(num) == "number"
end

function is_vector(vec)
   return is_number(vec.x)
      and is_number(vec.y)
      and is_number(vec.z)
end

function is_vec3(vec)
   return getmetatable(vec) == Vec3
end

function valid_number(num)
   return is_number(num) and num == num
end

function valid_vector(vec)
   return is_vector(vec)
      and valid_number(vec.x)
      and valid_number(vec.y)
      and valid_number(vec.z)
end

function assert_valid_number(num, msg)
   msg = msg or "Invalid number"
   if not valid_number(num) then
      assert(nil, "%s: %s", msg, num)
   end
end

function assert_valid_vector(vec, msg)
   msg = msg or "Invalid vector"
   if not valid_vector(vec) then
      assert(nil, "%s: %s", msg, vec)
   end
end

function unwrap(x)
   if getmetatable(x) == Vec3 then
      return x:unwrap()
   end

   return x
end

--- 3-vector constructor
function vec3(...)
   local args = {...}

   local vec = vector()
   if #args == 1 then
      local arg = args[1]
      assert_valid_vector(arg)
      vec:set(arg)
   elseif #args == 3 then
      assert_valid_number(args[1], "Invalid X component")
      assert_valid_number(args[2], "Invalid Y component")
      assert_valid_number(args[3], "Invalid Z component")
      vec:set(args[1], args[2], args[3])
   elseif #args ~= 0 then
      assert(nil, string.format("Invalid input: %s", args))
   end

   return setmetatable(
      { vec = vec },
      {
         __index = function(self, key)
            ---@diagnostic disable-next-line: undefined-field
            if Vec3.__classDict[key] then
               ---@diagnostic disable-next-line: undefined-field
               return Vec3.__classDict[key]
            elseif key == "x" then
               return self.vec.x
            elseif key == "y" then
               return self.vec.y
            elseif key == "z" then
               return self.vec.z
            end
         end
      }
   )
end

---@return vec3
function Vec3:validate()
   assert_valid_vector(self.vec)
   return self
end

---@return vector
function Vec3:copy()
   return vector():set(self.vec)
end

---@param x number|vector|vec3
---@return vec3
function Vec3:add(x)
   x = unwrap(x)

   if not valid_number(x) or not valid_vector(x) then
      assert(nil, "Input must be a number or vector")
   end

   return vec3(self:copy():add(x)):validate()
end

---@param x number|vector|vec3
---@return vec3
function Vec3:sub(x)
   x = unwrap(x)

   if not valid_number(x) or not valid_vector(x) then
      assert(nil, "Input must be a number or vector")
   end

   return vec3(self:copy():sub(x)):validate()
end

---@param x number|vector|vec3
---@return vec3
function Vec3:mul(x)
   x = unwrap(x)

   if not valid_number(x) or not valid_vector(x) then
      assert(nil, "Input must be a number or vector")
   end

   return vec3(self:copy():mul(x)):validate()
end

---@param x number|vector|vec3
---@return vec3
function Vec3:div(x)
   x = unwrap(x)

   if not valid_number(x) or not valid_vector(x) then
      assert(nil, "Input must be a number or vector")
   end

   return vec3(self:copy():div(x)):validate()
end

---@param x vector|vec3
---@return vec3
function Vec3:min(x)
   x = unwrap(x)
   assert_valid_vector(x)
   return vec3(self:copy():min(x)):validate()
end

---@param x vector|vec3
---@return vec3
function Vec3:max(x)
   x = unwrap(x)
   assert_valid_vector(x)
   return vec3(self:copy():max(x)):validate()
end

---@param x vector|vec3
---@return vec3
function Vec3:abs(x)
   x = unwrap(x)
   assert_valid_vector(x)
   return vec3(self:copy():abs(x)):validate()
end

---@param x vector|vec3
---@return number
function Vec3:dot(x)
   x = unwrap(x)
   assert_valid_vector(x)
   return self.vec:dotproduct(x)
end

---@param x vector|vec3
---@return vec3
function Vec3:cross(x)
   x = unwrap(x)
   assert_valid_vector(x)
   return vec3(vector_cross(self.vec, x)):validate()
end

---@return number
function Vec3:magnitude()
   return self.vec:magnitude()
end

---@return vec3
function Vec3:normalize()
   return vec3(self:copy():normalize()):validate()
end

---@return vec3
function Vec3:normalize_safe()
   return vec3(self:copy():normalize_safe()):validate()
end

---@return vec3
function Vec3:set_length(length)
   assert_valid_number(length, "Invalid length")
   return vec3(self:copy():set_length(length)):validate()
end

---@param x vector|vec3
---@return number
function Vec3:distance_to(x)
   x = unwrap(x)
   assert_valid_vector(x)
   return self.vec:distance_to(x)
end

---@param x vector|vec3
---@return number
function Vec3:distance_to_xz(x)
   x = unwrap(x)
   assert_valid_vector(x)
   return self.vec:distance_to_xz(x)
end

---@param x vector|vec3
---@return number
function Vec3:distance_to_sqr(x)
   x = unwrap(x)
   assert_valid_vector(x)
   return self.vec:distance_to_sqr(x)
end

---@param x vector|vec3
---@param y number
---@return vec3
function Vec3:lerp(x, y)
   x = unwrap(x)
   assert_valid_vector(x)
   assert_valid_number(y)
   return vec3(self:copy():lerp(x, y)):validate()
end

---@param x vector|vec3
---@return vec3
function Vec3:reflect(x)
   x = unwrap(x)
   assert_valid_vector(x)
   return vec3(self:copy():reflect(x)):validate()
end

---@param x vector|vec3
---@return vec3
function Vec3:slide(x)
   x = unwrap(x)
   assert_valid_vector(x)
   return vec3(self:copy():slide(x)):validate()
end

---@param x vector|vec3
---@return vec3
function Vec3:average(x)
   x = unwrap(x)
   assert_valid_vector(x)
   return vec3(self:copy():average(x)):validate()
end

---@return vec3
function Vec3:align()
   return vec3(self:copy():align()):validate()
end

---@param x vector|vec3
---@return vec3
function Vec3:invert(x)
   x = unwrap(x)
   assert_valid_vector(x)
   return vec3(self:copy():invert()):validate()
end

---@param x number|vector|vec3
---@param y number|vector|vec3
---@return vec3
function Vec3:mad(x, y)
   x = unwrap(x)
   y = unwrap(y)
   assert_valid_vector(x)
   if not valid_vector(y) or valid_number(y) then
      assert(nil, string.format("Invalid input: %s", y))
   end
   return vec3(self:copy():mad(x, y)):validate()
end

---@param x vector|vec3
---@return vec3
function Vec3:clamp(x)
   x = unwrap(x)
   assert_valid_vector(x)
   return vec3(self:copy():clamp(x)):validate()
end

-- TODO: Figure out what these do
--[[
function Vec3:getP()
   return self.vec:getP()
end

function Vec3:getH()
   return self.vec:getH()
end

function Vec3:setHP(number, number)
   return vec3(self:copy():setHP()):validate()
end

function Vec3:inertion(x)
   assert_valid_number(x)
   return self:copy():inertion(x)
end

function Vec3:similar(x)
   assert_valid_number(x)
   return self:similar(x)
end
--]]
